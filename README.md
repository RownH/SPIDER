# SPIDER

1. 这是一个爬虫系统，适用于新手这种没项目，又可以用巩固操作系统，网络编程等知识
2. 主要采用的是C语言风格，从main函数一步步往下走，没有封装，继承等概念
3. 这个项目是玩玩全全仿照传智播客的一个爬虫项目，同时在理解他们这些源码的同时加上了注释

主要用到的知识：
- linux的线程使用方法
- 守护进程的创建
- libevent库来解析DNS
- epoll对事件的监听
- 如何调用动态库
- socket编程
- 正则表达式解析页面
- 文件系统
- 各种字符串的处理方法
...

## 主处理流程
爬虫相当于是一个客户端请求浏览器的资源，再进行保存，保存的页面又可以解析出新的页面，直到达到截断条件。
1. 获取命令行参数
	类似于./app [option]给出相应的option操作
2. 读取配置文件
	系统是用来爬虫的，所以一开始的种子，调用的模块名，等信息需要读取出来
3. 载入配置文件中的模块，进行相应的设置
4. 种子加入队列，扔到一个线程中进行DNS解析
5. 创建epoll任务，
	取出一个url，创建socket通信。将这个socket加入epoll里面进行关注
6. epoll_wait返回活跃的时间，每一个活跃的事件开启一个线程进行页面处理
	在这个线程里面，会提取页面的url。url如果是新的，那么就会在结束的时候调用epoll任务，使得这个新的url可以被epoll关注
7. 新的url能加入了，那么主要的就是循环第6步

核心的数据结构体和函数接口提前想好：

## 配置文件解析
//配置文件中应该有的变量

	typedef struct Config
	{
		int 	max_job_num;//最大的任务数
		char* 	seeds;//原始种子
		char*	logfile;//日志文件名称
		int 	log_level;//日志的等级
		int 	max_depth;//每个url的最大深度
		char*	module_path;//模块的路径
		vector<char*>	modules;//哪些模块可以被加载
		vector<char*>	accept_types;//保存的时候可以支持的类型
	}
	
	extern Config* initconfig();//配置文件的全局变量初始化
	extern void loadconfig(Config* conf);//读取配置文件


## 动态模块的载入
(1）结构清晰、易于理解。由于借鉴了硬件总线的结构，而且各个插件之间是相互独立的，所以结构非常清晰也更容易理解。
(2）易修改、可维护性强。由于插件与宿主程序之间通过接口联系，就像硬件插卡一样，可以被随时删除，插入和修改，所以结构很灵活，容易修改，方便软件的升级和维护。
(3）可移植性强、重用力度大。因为插件本身就是由一系列小的功能结构组成，而且通过接口向外部提供自己的服务，所以复用力度更大，移植也更加方便。
(4）结构容易调整。系统功能的增加或减少，只需相应的增删插件，而不影响整个体系结构，因此能方便的实现结构调整。：
(5）插件之间的耦合度较低。由于插件通过与宿主程序通信来实现插件与插件，插件与宿主程序间的通信，所以插件之间的耦合度更低。
(6）可以在软件开发的过程中修改应用程序。由于采用了插件的结构，可以在软件的开发过程中随时修改插件，也可以在应用程序发行之后，通过补丁包的形式增删插件，通过这种形式达到修改应用程序的目的。
(7）灵活多变的软件开发方式。可以根据资源的实际情况来调整开发的方式，资源充足可以开发所有的插件，资源不充足可以选择开发部分插件，也可以请第三方的厂商开发，用户也可以根据自己的需要进行开发。 

对于一个cpp，怎么载入呢？

使用时在dlopen（）函数以指定模式打开指定的动态链接库文件，并返回一个句柄给dlsym（）的调用进程。使用dlclose（）来卸载打开的库 
### dlopen
功能：打开一个动态链接库
包含头文件： dlfcn.h
函数定义： void * dlopen( const char * pathname, int mode );
函数描述： 在dlopen的（）函数以指定模式打开指定的动态连接库文件，并返回一个句柄给调用进程。使用dlclose（）来卸载打开的库。
　　mode：模式有下面这些
　　RTLD_LAZY 暂缓决定，等有需要时再解出符号
　　RTLD_NOW 立即决定，返回前解除所有未决定的符号。
　　RTLD_LOCAL
　　RTLD_GLOBAL 允许导出符号
　　RTLD_GROUP
　　RTLD_WORLD
返回值: 打开错误返回NULL ，成功，返回库引用 ，编译时候要加入 -ldl (指定dl库) 

### dlsym
功能：根据动态链接库操作句柄与符号，返回符号对应的地址。
包含头文件：dlfcn.h
函数定义：void\*dlsym(void\* handle,const char* symbol)
函数描述：dlsym根据动态链接库操作句柄(handle)与符号(symbol)，返回符号对应的地址。使用这个函数不但可以获取函数地址，也可以获取变量地址。handle是由dlopen打开动态链接库后返回的指针，symbol就是要求获取的函数或全局变量的名称。 

### dlclose
dlclose用于关闭指定句柄的动态链接库，只有当此动态链接库的使用计数为0时,才会真正被系统卸载。

假设在my.so中定义了一个void mytest()函数，那在使用my.so时先声明一个函数指针： 
void(\*pMytest)(); 
接下来先将那个my.so载入： 
pHandle=dlopen("my.so",RTLD_LAZY);//详见dlopen函数 然后使用dlsym函数将函数指针 pMytest 指向 mytest() 函数：
pMytest=(void(\*)())
dlsym(pHandle,"mytest");//可见放在双引号中的mytest不用加括号,即使有参数也不用 （可调用dlerror();返回错误信息，正确返回为空）！

//无论什么模块都考虑因该有以下的信息

	typedef struct Module
	{
		int version;
		int minor_version;
		const char* name;
		void (*init)(Module*);//每个模块都有init初始化函数，这样动态载入的时候可以调用这个模块的函数进行初始化
		int (*handle)(void *);//这个就相当于每个模块都有这么一个入口，
	} Module;
不同模块初始化的作用是，将这个模块加入不同的功能体的队列中：
处理HTTP响应头的；vector
处理html模块的；vector
判断url是否有效的；vector

这样在模块设计的时候，在模块中给出相应的结构体，就能通过这个结构体去访问
比如：savehtml模块
通过动态库的调用，可以访问saveimage这个结构体，通过结构体中的内容就可以访问具体的函数：

	static int handler()
	{
	}
	static void init()
	{
	}
	Module saveimage = 
	{
		//版本信息变量
		init,
		handler
	};



